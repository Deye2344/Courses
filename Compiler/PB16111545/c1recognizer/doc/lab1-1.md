### C1Lexer.g4的难点

#### 1. Identifier

51页

需要参考 *ISO IEC 9899* 以及[ANTLR Lexer规则](https://github.com/ANTLR/antlr4/blob/master/doc/lexer-rules.md) 以下不再重复提起

与正常标识符一样，字符或者下划线或者数字，但是数字不能作为开头

写成ANTLR v4能识别的格式就是

```
[a-zA-Z_] [a-zA-Z0-9_]* 
```

#### 2. IntConst

54页

实验文档要求可以忽略后缀，简化了正规定义

数字可以是十进制，十六进制，八进制，规则是常规的

十进制

```
[1-9][0-9]* | '0'
```

十六进制

```
('0x'|'0X') [0-9a-fA-F]+
```

八进制

```
'0' [0-7]+
```

最终的结果是

```
([1-9][0-9]* | '0') | (('0x'|'0X') [0-9a-fA-F]+) | ('0' [0-7]+)
```

#### 3. FloatConst

57页

实验文档要求忽略后缀与十六进制的浮点数
$$
fractional-constant  \, exponent-part_{opt} \\
digit-sequence \, exponent-part
$$


即

```
([0-9]* '.'  [0-9]+ | [0-9]+ '.' ) ([eE] [+-] [0-9]+)?
```

或者

```
[0-9]+ [eE] [+-] [0-9]+
```

最终显示为

```
 ([0-9]* '.'  [0-9]+ | [0-9]+ '.' ) ([eE] [+-]? [0-9]+)? | [0-9]+ [eE] [+-]? [0-9]+
```

#### 4. Comment

66页

##### BlockComment

这个相对容易，使用`*?`表示non-greedy

```
'/*' .*? '*/' -> skip
```

##### LineComment

此处需要注意

Unix系统里，每行结尾只有“<换行>”，即“\n”； 

Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；

以及 在每行的末尾用`\`表示连下一行

```
('//' | '/' ( '\\' '\r'? '\n')+ '/' ) ~[\n]*? ( '\\' '\r'? '\n' ~[\n]*?)* '\r'? '\n'
```

### 测试方法

在`grammar`目录下

`make` 表示编译lexer

`make clean`清除

`make test`手动输入测试文本

`make example`测试在`c1recognizer/test/test_cases/lexer`下的所有测试案例

### 测试案例说明

由于已经有一般场景的测试，所以只增加关于数字与注释的测试。

其中，注释着重测试了`\`在`//`中表示换行连接的作用

数字着重测试了整数和浮点数的各种表达





