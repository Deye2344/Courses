\subsection{函数参数合法性检查}
\label{sec:core:arg}

该项检查针对竞赛要求第二点进行实现，本参赛队对第二点的需求理解为：
考虑编译单元$U$ (一个C 程序文件为一个编译单元)中的函数$F$，
当$F$向编译单元外暴露时，即$F$未被 $static$ 修饰，
需要检查 $F$ 的输入参数的合法性；
否则，不需要检查 $F$ 的输入参数的合法性。
当 $F$ 调用函数 $G$ 时，如果 $G$ 与 $F$ 都在同一个编译单元 $U$ 中且不对外暴露，
那么 $G$ 参数的合法性将由 $F$ 负责检查，
否则 $F$ 不需要保证 $G$ 调用参数的合法性检查。

在上述理解中，“检查”针对的对象是内存区域存储的右值。
若内存区域的右值直接作为分支条件表达式的操作数，
那么就认为相应内存区域的右值得到检查。

本工具基于{\bf 不信任传播}的思想实现上述需求。
首先，根据需求设置某些内存区域右值为不信任源，
如需要检查的函数形参右值；
然后，
由不信任的右值经运算后导出的其他右值也不被信任。
当不信任的右值被读取时，本工具将产生警告；
当程序代码有对不信任的内存区域右值的“检查”，
则该右值获得信任，并且该右值定值时所依赖的所有内存区域右值也获得信任。


本工具采用Clang提供的静态分析框架对输入的源C 程序文件进行
基于符号执行的路径敏感的过程内分析。
在分析中，追踪的程序点状态定义如\autoref{equ:module_check_state}所示。
其中$S_1$表示内存区域右值（Memory Region Values, 简记RV）的信任状态，
$T$表示信任，$U$表示不信任；
$S_2$表示内存区域右值到最近一次定值时依赖的内存区域右值集合。
% 前者主要是为了在读取内存区域右值是判断是否右值检查过，
% 后者的目的主要是为了支持间接检查的情况，
% 典型的情况如需要错误处理的函数调用，
% 当函数调用返回的错误指示尚未检查前，该函数岀参可能存在错误，被认为处于未检查状态；
% 当错误指示检查后，认为函数岀参相应的处于已检查状态。

\begin{equation}
\label{equ:module_check_state}
S = \{
S_1 : RVs \mapsto \{T, U\}, 
S_2 : RVs \mapsto \{RVs\}
\}
\end{equation}

在上述程序状态基础上，
定义如\autoref{fig:module_check} 所示的转换规则和检查动作，
其中函数$Value()$接收一个左值并返回对应右值，
函数 $DependentRegionValues()$ 接收一个表达式 $E$
并返回 $E$ 中直接依赖的内存区域右值。
\input{core/algo_moduleck}
